---
title: "CUT&RUN In Bioconductor (part5) <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_CUT&RUN/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no" 
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T) # delete cache before any merging 

```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# CUT&RUN/ATAC (part 5) - Peak annotation and functional enrichment

---
"    
  )
  
}

```


```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Peak Annotation

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Peak Annotation

---
"    
  )
  
}

```


## Annotation of peaks to genes

So far we have been working with CUT&RUN peaks corresponding to transcription factor binding or ATACseq peaks corresponding to open chromatin regions. Transcription factors, as implied in the name, can affect the expression of their target genes and open regions generally correlate with gene expression.

We will often annotate peaks to genes to try and identify the target of a transcription factor or a gene regulated by a regulatory element uncovered by ATACseq. This is typically done using a simple set of rules:

Peaks are typically annotated to a gene if
* They overlap the gene.
* The gene is the closest (and within a minimum distance).



---

## Peak annotation


A useful package for annotation of peaks to genes is **ChIPseeker**. 

By using pre-defined annotation in the from of a **TXDB** object for mouse (mm10 genome), ChIPseeker will provide us with an overview of where peaks land in the gene and distance to TSS sites.

First load the libraries we require for the next part and read in our SOX9 CUT&RUN peaks from Chromosome 18. 


```{r,echo=T, eval=T, echo=T, warning=FALSE,tidy=T,message=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)
library(rtracklayer)

cnrPeaks_GR <- rtracklayer::import("data/SOX9CNR_W6_rep1_macs_peaks.narrowPeak")
```

---

## Peak annotation


The annotatePeak function accepts a GRanges object of the regions to annotate, a TXDB object for gene locations and a database object name to retrieve gene names from.


```{r,eval=T,echo=T, message=FALSE,messages=FALSE, eval=T, echo=T, warning=FALSE}
peakAnno <- annotatePeak(cnrPeaks_GR, tssRegion=c(-500, 500), 
                         TxDb=TxDb.Mmusculus.UCSC.mm10.knownGene, 
                         annoDb="org.Mm.eg.db")
class(peakAnno)
```
---
## Peak annotation

The result is a csAnno object containing annotation for peaks and overall annotation statistics.

```{r,eval=T,echo=T, message=F,messages=F, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno
```

---
## Peak annotation


The csAnno object contains the information on annotation of individual peaks to genes.

To extract this from the csAnno object the ChIPseeker functions *as.GRanges* or *as.data.frame* can be used to produce the respective object with peaks and their associated genes.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
annotatedPeaksGR <- as.GRanges(peakAnno)
annotatedPeaksDF <- as.data.frame(peakAnno)
```

---
## Peak annotation
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
annotatedPeaksGR[1:2,]
```

---
## Vizualising peak annotation

Now we have the annotated peaks from ChIPseeker we can use some of ChIPseeker's plotting functions to display distribution of peaks in gene features. Here we use the **plotAnnoBar** function to plot this as a bar chart but  **plotAnnoPie** would produce a similar plot as a pie chart.


```{r, eval=T, echo=T, fig.height=5, fig.width=15, warning=FALSE, tidy=T}
plotAnnoBar(peakAnno)
```

---
## Vizualising peak annotation

Similarly we can plot the distribution of peaks around TSS sites.


```{r,eval=T,echo=T, eval=F, echo=T, warning=FALSE,fig.height=5, fig.width=15,tidy=T}
plotDistToTSS(peakAnno)
```

![](imgs/TSS1.png)

---
# Vizualising peak annotation

ChIPseeker can also offer a succinct plot to describe the overlap between annotations.


```{r, eval=T, echo=T, fig.height=5, fig.width=15, warning=FALSE, tidy=T}
library(ggupset)
upsetplot(peakAnno, vennpie=F)
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Gene Set Enrichment

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Gene Set Enrichment

---
"    
  )
  
}

```

## Gene Set testing

Transcription factors or epigenetic marks may act on specific sets of genes grouped by a common biological feature (shared Biological function, common regulation in RNAseq experiment etc).

A frequent step in CUT&RUN analysis is to test whether common gene sets are enriched for transcription factor binding or epigenetic marks.

Sources of well curated gene sets include [GO consortium](http://geneontology.org/) (gene's function, biological process and cellular localisation), [REACTOME](http://www.reactome.org/) (Biological Pathways) and [MsigDB](http://software.broadinstitute.org/gsea/msigdb/) (Computationally and Experimentally derived).

---
## Gene Set testing for CUT&RUN

Gene set enrichment testing may be performed on the sets of genes with peaks associated to them. In this example we will consider genes with peaks within 1000bp of a gene's TSS.

We will not access these database libraries directly in testing but will use other R/Bioconductor libraries which make extensive use of them.


<div align="center">
<img src="imgs/TSSPeak.png" alt="offset" height="250" width="600">
</div>

---
## Gene ontology and gene set testing

To perform gene set testing here, we will use the **clusterProfiler package**.

clusterProfiler provides multiple enrichment functions that allow for comparison of your gene list to known (e.g. GO, KEGG) or custom gene sets. Detailed information about all of the functionality within this package is available [here](http://yulab-smu.top/clusterProfiler-book/).

In this example we use all TSS sites we found to be overlapped by Sox9 peaks.

The peaks landing in TSS regions will be marked as "Promoter" in the **annotation** column of our annotated GRanges object.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
annotatedPeaksGR[1:2,]
```


---
## Gene ontology and gene set testing


We can extract the unique names of genes with peaks in their TSS by subsetting the annotated GRanges and retrieving gene names from the **geneId** column.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
annotatedPeaksGR_TSS <- annotatedPeaksGR[annotatedPeaksGR$annotation == "Promoter",]
genesWithPeakInTSS <- unique(annotatedPeaksGR_TSS$geneId)
genesWithPeakInTSS[1:2]
```

---
## Gene ontology and functional testing


Next we can extract all genes which are included in the TxDb object to use as our universe of genes for pathway enrichment.


```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T, message = F}
allGeneGR <- genes(TxDb.Mmusculus.UCSC.mm10.knownGene)
allGeneGR[1:2,]
allGeneIDs <- allGeneGR$gene_id
```

---
## Gene ontology and functional testing

Once we have our gene list and the universe of genes in the same format, we can use them in the **enrichGO** function to perform gene ontology analysis

For the **ont** argument, we can choose between the "BP", "MF", and "CC" subontologies, or "ALL" for all three.

```{r,eval=T,echo=T, message=F, warning=FALSE,tidy=T}
library(clusterProfiler)
library(org.Mm.eg.db)
GO_result <- enrichGO(gene = genesWithPeakInTSS, 
                      universe = allGeneIDs,
                      OrgDb = org.Mm.eg.db,
                      ont = "BP",
                      pvalueCutoff = 0.2,
                      qvalueCutoff = 0.2)

```

---
## Gene ontology and functional testing

We now have an **enrichResult** instance. From this object, we can extract a data frame of the most highly enriched gene ontology categories.
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
GO_result_df <- data.frame(GO_result)
GO_result_df[1:5, ]
```

---
## Gene ontology and functional testing

Network plots can be generated from any enrichResult object using the **enrichplot** package.

We measure similarities between the various significant gene sets and group them accordingly. The **showCategory** argument specifies how many top gene ontology hits to show. 
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T, fig.height=4, fig.width=8}
library(enrichplot)
GO_result_plot <- pairwise_termsim(GO_result)
emapplot(GO_result_plot, showCategory = 20, cex_label_category = 0.6)
```


---
## Gene ontology and functional testing

In addition to gene ontology, we can test our gene list against custom gene sets that we import as gmt files using the clusterProfiler **enricher** function. Similar to the enrichGO function, this will produce an enrichResult object that can be used for visualization. 

Here we will get gene sets from MSigDB using the **msigdbr** package. We can use this package to pull out specific gene sets, which can be seen [at this link](http://software.broadinstitute.org/gsea/msigdb/). We can also run the **msigdbr_collections** function to see the categories and subcategory codes that will be used for accessing the gene sets. 

````{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(msigdbr)
msigdbr_collections()
```

---

## Gene ontology and functional testing

From the data frame on the previous slide we can identify the category/subcategory we want, and use those in the **msigdbr** function. Here we will use "H" to access the Hallmark gene sets, and in the end we need to get a data frame where the first column contains the name of the gene sets and the second column contains the gene ID. 

````{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(msigdbr)
msig_t2g <- msigdbr(species = "Mus musculus", 
                    category = "H", 
                    subcategory = NULL)
msig_t2g <- msig_t2g[ , colnames(msig_t2g) %in% c("gs_name", "entrez_gene")]
msig_t2g[1:3, ]
```

---
## Gene ontology and functional testing

We then run the gene set enrichment, using the term to gene mapping we created as the **TERM2GENE** argument in the enricher function. 
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
hallmark <- enricher(gene = genesWithPeakInTSS, 
                     universe = allGeneIDs,
                     TERM2GENE = msig_t2g)
hallmark_df <- data.frame(hallmark)
hallmark_df[1:5, ]
```



## GREAT for GO and functional testing

In addition to a standard enrichment tests, methods have been implemented specifically for CUT&RUN. Many of these tools aim to incorporate peaks distal to genes into their enrichment testing such as the popular [GREAT](http://bejerano.stanford.edu/great/public/html/splash.php) toolset.

Incorporating distal peaks by rules such as nearest gene results in some genes having a higher chance of being selected and hence some gene sets as a whole having a higher chance of having its members selected.

[GREAT](http://bejerano.stanford.edu/great/public/html/splash.php) defines regulatory regions for each individual gene and compares the proportion of peaks mapping to a gene set's regulatory regions to the proportion of the genome occupied by gene set's regulatory regions.

i.e. If a gene set's regulatory regions account for 1% of the genome then one might expect 1% of peaks to overlap these regions by chance.

---

## rGREAT - R interface to GREAT server


We can use the GREAT Bioconductor interface available in the rGREAT package. 

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(rGREAT)
```
---

## rGREAT for GO and functional testing


To submit jobs we can use our GRanges of Myc peaks and specify a genome with the **submitGreatJob** function.

This function returns a GreatJob object containing a reference to our results on the GREAT server. To review the categories of results available we can use the availableCategories function on our GreatJob object.

```{r,eval=T,echo=T, eval=T, echo=T,messages=F,message=F,warning=FALSE,tidy=T}
great_Job <- submitGreatJob(cnrPeaks_GR,species="mm10",version = "4",request_interval = 1)
availableCategories(great_Job)
```
---

## rGREAT for GO and functional testing


The results table can be retrieved using the getEnrichmentTables function and specifying which tables we wish to review.

Here we retrieve the results tables for the "GO" gene sets. All three GO gene lists are included in the result.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE, message =F}
great_ResultTable = getEnrichmentTables(great_Job,
                                        category="GO")
names(great_ResultTable)
```
---

## rGREAT for GO and functional testin


Now we can review the enrichment of our genes with Myc peaks in their TSS for the "MSigDB Predicted Promoter Motifs" gene sets.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
greatGO <- great_ResultTable[["GO Biological Process"]]
greatGO[1:10,]
```

---

```{r}

cnR_notProm <- annotatedPeaksGR[!annotatedPeaksGR$annotation == "Promoter"]

atacPeaks_GR <- rtracklayer::import("data/W6_ATAC_rep1_macs_peaks.narrowPeak")

cnR_notProm_atac <- cnR_notProm[cnR_notProm %over% atacPeaks_GR]

great_Job_overlap <- submitGreatJob(cnR_notProm_atac,species="mm10",version = "4",request_interval = 1)
great_ResultTable_overlap = getEnrichmentTables(great_Job_overlap,
                                        category="GO")
greatGO_overlap <- great_ResultTable_overlap[["GO Biological Process"]]
greatGO_overlap[1:10,]
```


---

## Time for an exercise!

Exercise on CUT&RUN data can be found [here](../../exercises/exercises/CUT&RUN_part1_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/CUT&RUN_part1_answers.html)

R code for solutions can be found [here](../../exercises/answers/CUT&RUN_part1_answers.R)


