---
title: "CUT&RUN In Bioconductor (part3) <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_CUT&RUN/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no" 
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T) # delete cache before any merging 

```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# CUT&RUN (part 3)

---
"    
  )
  
}

```


```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Peak Annotation

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Peak Annotation

---
"    
  )
  
}

```


## Annotation of peaks to genes

So far we have been working with ChIPseq peaks corresponding to transcription factor binding. Transcription factors, as implied in the name, can affect the expression of their target genes.

The target of a transcription factor is hard to assertain from ChIPseq data alone and so often we will annotate peaks to genes by a simple set of rules:

Peaks are typically annotated to a gene if
* They overlap the gene.
* The gene is the closest (and within a minimum distance).



---

## Peak annotation


A useful package for annotation of peaks to genes is **ChIPseeker**. 

By using pre-defined annotation in the from of a **TXDB** object for mouse (mm10 genome), ChIPseeker will provide us with an overview of where peaks land in the gene and distance to TSS sites.

First load the libraries we require for the next part.

```{r,include=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)

```

```{r,eval=F,echo=T, eval=T, echo=T, warning=FALSE,tidy=T,message=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)

```

---

## Peak annotation


The annotatePeak function accepts a GRanges object of the regions to annotate, a TXDB object for gene locations and a database object name to retrieve gene names from.


```{r,eval=T,echo=T, message=FALSE,messages=FALSE, eval=T, echo=T, warning=FALSE}
peakAnno <- annotatePeak(macsPeaks_GR, tssRegion=c(-500, 500), 
                         TxDb=TxDb.Mmusculus.UCSC.mm10.knownGene, 
                         annoDb="org.Mm.eg.db")
class(peakAnno)
```
---
## Peak annotation

The result is a csAnno object containing annotation for peaks and overall annotation statistics.

```{r,eval=T,echo=T, message=F,messages=F, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno
```

---
## Peak annotation


The csAnno object contains the information on annotation of individual peaks to genes.

To extract this from the csAnno object the ChIPseeker functions *as.GRanges* or *as.data.frame* can be used to produce the respective object with peaks and their associated genes.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno_GR <- as.GRanges(peakAnno)
peakAnno_DF <- as.data.frame(peakAnno)
```

---
## Peak annotation
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno_GR[1:2,]
```

---
## Vizualising peak annotation

Now we have the annotated peaks from ChIPseeker we can use some of ChIPseeker's plotting functions to display distribution of peaks in gene features. Here we use the **plotAnnoBar** function to plot this as a bar chart but  **plotAnnoPie** would produce a similar plot as a pie chart.


```{r, eval=T, echo=T, fig.height=5, fig.width=15, warning=FALSE, tidy=T}
plotAnnoBar(peakAnno)
```

---
## Vizualising peak annotation

Similarly we can plot the distribution of peaks around TSS sites.


```{r,eval=T,echo=T, eval=F, echo=T, warning=FALSE,fig.height=5, fig.width=15,tidy=T}
plotDistToTSS(peakAnno)
```

![](imgs/TSS1.png)

---
# Vizualising peak annotation

ChIPseeker can also offer a succinct plot to describe the overlap between annotations.


```{r, eval=T, echo=T, fig.height=5, fig.width=15, warning=FALSE, tidy=T}
upsetplot(peakAnno, vennpie=F)
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Gene Set Enrichment

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Gene Set Enrichment

---
"    
  )
  
}

```

## Gene Set testing

Transcription factors or epigenetic marks may act on specific sets of genes grouped by a common biological feature (shared Biological function, common regulation in RNAseq experiment etc).

A frequent step in ChIPseq analysis is to test whether common gene sets are enriched for transcription factor binding or epigenetic marks.

Sources of well curated gene sets include [GO consortium](http://geneontology.org/) (gene's function, biological process and cellular localisation), [REACTOME](http://www.reactome.org/) (Biological Pathways) and [MsigDB](http://software.broadinstitute.org/gsea/msigdb/) (Computationally and Experimentally derived).

---
## Gene Set testing for ChIPseq

Gene set enrichment testing may be performed on the sets of genes with peaks associated to them. In this example we will consider genes with peaks within 1000bp of a gene's TSS.

We will not access these database libraries directly in testing but will use other R/Bioconductor libraries which make extensive use of them.


<div align="center">
<img src="imgs/TSSPeak.png" alt="offset" height="250" width="600">
</div>

---
## Gene ontology and gene set testing

To perform gene set testing here, we will use the **clusterProfiler package**.

clusterProfiler provides multiple enrichment functions that allow for comparison of your gene list to known (e.g. GO, KEGG) or custom gene sets. Detailed information about all of the functionality within this package is available [here](http://yulab-smu.top/clusterProfiler-book/).

In this example we use all TSS sites we found to be overlapped by Myc peaks.

The peaks landing in TSS regions will be marked as "Promoter" in the **annotation** column of our annotated GRanges object.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
annotatedPeaksGR[1,]
```


---
## Gene ontology and gene set testing


We can extract the unique names of genes with peaks in their TSS by subsetting the annotated GRanges and retrieving gene names from the **geneId** column.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
annotatedPeaksGR_TSS <- annotatedPeaksGR[
  annotatedPeaksGR$annotation == "Promoter",]
genesWithPeakInTSS <- unique(annotatedPeaksGR_TSS$geneId)
genesWithPeakInTSS[1:2]
```

---
## Gene ontology and functional testing


Next we can extract all genes which are included in the TxDb object to use as our universe of genes for pathway enrichment.


```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T, message = F}
allGeneGR <- genes(TxDb.Mmusculus.UCSC.mm10.knownGene)
allGeneGR[1:2,]
allGeneIDs <- allGeneGR$gene_id
```

---
## Gene ontology and functional testing

Once we have our gene list and the universe of genes in the same format, we can use them in the **enrichGO** function to perform gene ontology analysis

For the **ont** argument, we can choose between the "BP", "MF", and "CC" subontologies, or "ALL" for all three.

```{r,eval=T,echo=T, message=F, warning=FALSE,tidy=T}
library(clusterProfiler)
library(org.Mm.eg.db)
GO_result <- enrichGO(gene = genesWithPeakInTSS, 
                      universe = allGeneIDs,
                      OrgDb = org.Mm.eg.db,
                      ont = "BP")

```

---
## Gene ontology and functional testing

We now have an **enrichResult** instance. From this object, we can extract a data frame of the most highly enriched gene ontology categories.
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
GO_result_df <- data.frame(GO_result)
GO_result_df[1:5, ]
```

---
## Gene ontology and functional testing

Network plots can be generated from any enrichResult object using the **enrichplot** package.

We measure similarities between the various significant gene sets and group them accordingly. The **showCategory** argument specifies how many top gene ontology hits to show. 
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T, fig.height=4, fig.width=8}
library(enrichplot)
GO_result_plot <- pairwise_termsim(GO_result)
emapplot(GO_result_plot, showCategory = 20)
```


---
## Gene ontology and functional testing

In addition to gene ontology, we can test our gene list against custom gene sets that we import as gmt files using the clusterProfiler **enricher** function. Similar to the enrichGO function, this will produce an enrichResult object that can be used for visualization. 

Here we will get gene sets from MSigDB using the **msigdbr** package. We can use this package to pull out specific gene sets, which can be seen [at this link](http://software.broadinstitute.org/gsea/msigdb/). We can also run the **msigdbr_collections** function to see the categories and subcategory codes that will be used for accessing the gene sets. 

````{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(msigdbr)
msigdbr_collections()
```

---

## Gene ontology and functional testing

From the data frame on the previous slide we can identify the category/subcategory we want, and use those in the **msigdbr** function. Here we will use "H" to access the Hallmark gene sets, and in the end we need to get a data frame where the first column contains the name of the gene sets and the second column contains the gene ID. 

````{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(msigdbr)
msig_t2g <- msigdbr(species = "Mus musculus", 
                    category = "H", 
                    subcategory = NULL)
msig_t2g <- msig_t2g[ , colnames(msig_t2g) %in% c("gs_name", "entrez_gene")]
msig_t2g[1:3, ]
```

---
## Gene ontology and functional testing

We then run the gene set enrichment, using the term to gene mapping we created as the **TERM2GENE** argument in the enricher function. 
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
hallmark <- enricher(gene = genesWithPeakInTSS, 
                     universe = allGeneIDs,
                     TERM2GENE = msig_t2g)
hallmark_df <- data.frame(hallmark)
hallmark_df[1:3, ]
```

---
## Gene ontology and functional testing

We learned about the **goseq** package during the RNAseq course, which is another functional annotation package similar to clusterProfiler,

Here we perform the same enrichment test for the MSigDB Hallmark gene sets. 

For goseq, we need a named vector of all genes (the universe) with 1s or 0s representing whether a gene had peak in TSS or not. 
We can turn a logical vector into 1 for TRUE and 0 for FALSE simply using the **as.integer** function.

```{r,eval=T,echo=T, warning=FALSE,tidy=T}
allGenesForGOseq <- as.integer(allGeneIDs %in% genesWithPeakInTSS)
names(allGenesForGOseq) <- allGeneIDs
allGenesForGOseq[1:3]
```

---
## Gene ontology and functional testing

First we must construct a **nullp** data.frame for use within **goseq** using the **nullp** function and supplying our named vector, genome to be used and gene identifier used.

The **nullp** function attempts to correct for gene length biases we may see in gene set testing. i.e. a longer gene may have more chance to have a peak within it.


```{r,include=FALSE}
library(goseq)
```

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(goseq)
pwf=nullp(allGenesForGOseq,"mm10","knownGene",plot.fit=FALSE)

```


---
## Gene ontology and functional testing

We can use the same term to gene mapping we used for clusterProfiler (though it must be converted from a tibble to data frame for goseq) to run the gene set enrichment test.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE, message = F, tidy=T}
Myc_hallMarks <- goseq(pwf,"mm10","knownGene",
                       gene2cat = data.frame(msig_t2g))

Myc_hallMarks[1:3, ]
```

---


## GREAT for GO and functional testing

In addition to a standard enrichment tests, methods have been implemented specifically for ChIPseq. Many of these tools aim to incorporate peaks distal to genes into their enrichment testing such as the popular [GREAT](http://bejerano.stanford.edu/great/public/html/splash.php) toolset.

Incorporating distal peaks by rules such as nearest gene results in some genes having a higher chance of being selected and hence some gene sets as a whole having a higher chance of having its members selected.

[GREAT](http://bejerano.stanford.edu/great/public/html/splash.php) defines regulatory regions for each individual gene and compares the proportion of peaks mapping to a gene set's regulatory regions to the proportion of the genome occupied by gene set's regulatory regions.

i.e. If a gene set's regulatory regions account for 1% of the genome then one might expect 1% of peaks to overlap these regions by chance.

---
rGREAT - R interface to GREAT server
=========================================================

We can use the GREAT Bioconductor interface available in the rGREAT package. 

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
library(rGREAT)
```
---
rGREAT for GO and functional testing
=========================================================

To submit jobs we can use our GRanges of Myc peaks and specify a genome with the **submitGreatJob** function.

This function returns a GreatJob object containing a reference to our results on the GREAT server. To review the categories of results available we can use the availableCategories function on our GreatJob object.

```{r,eval=T,echo=T, eval=T, echo=T,messages=F,message=F,warning=FALSE,tidy=T}
great_Job <- submitGreatJob(macsPeaks_GR,species="mm10",version = "3.0.0",request_interval = 1)
availableCategories(great_Job)
```
---
rGREAT for GO and functional testing
=========================================================

The results table can be retrieved using the getEnrichmentTables function and specifying which tables we wish to review.

Here we retrieve the results tables for the "Regulatory Motifs" gene sets which contains 2 separate database results.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE, message =F}
great_ResultTable = getEnrichmentTables(great_Job,
                                        category="Regulatory Motifs")
names(great_ResultTable)
```
---
rGREAT for GO and functional testin
=========================================================

Now we can review the enrichment of our genes with Myc peaks in their TSS for the "MSigDB Predicted Promoter Motifs" gene sets.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
msigProMotifs <- great_ResultTable[["MSigDB Predicted Promoter Motifs"]]
msigProMotifs[1:4,]
```



---

## Time for an exercise!

Exercise on CUT&RUN data can be found [here](../../exercises/exercises/CUT&RUN_part1_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/CUT&RUN_part1_answers.html)

R code for solutions can be found [here](../../exercises/answers/CUT&RUN_part1_answers.R)


